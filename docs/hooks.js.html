<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hooks.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hooks.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Custom React hook for ease of state management with use of SlashDB and SDK.
 */
// import React built-in hooks to use under the hood.
import { useState, useEffect, useContext, useRef } from 'react';



// import custom context for retrieving primary SlashDB instance config
import { SlashDBContext } from './Context';

// required JavaScript SDK classes
import { SlashDBClient } from '@slashdb/js-sdk/modules/slashdbclient.js';
import { DataDiscoveryResource } from "@slashdb/js-sdk/modules/datadiscovery.js";
import { SQLPassThruQuery } from "@slashdb/js-sdk/modules/sqlpassthru.js";


// list of SlashDB clients for use by hooks
const sdbClientRegistry = {}
/**
 * Create a SlashDB client object for use with hooks and store in a local registry.  If no parameters are provided, create a client object using
 * the parameters configured with the SlashDBProvider component
 * @param {string} [instanceName] a name to identify the client in the registry; if not provided, will be named 'default'
 * @param {string} [host] hostname of the SlashDB instance to connect to, with protocol/port
 * @param {string} [username] username for SlashDB client to authenticate with
 * @param {string} [apiKey] API key for the username
 * @returns {SlashDBClient} a reference to the SlashDB client that was created
  */
const useSetUp = (instanceName = 'default', host = undefined, username = undefined, apiKey = undefined ) => {
  
  // // if instance already exists and host parameter is provided, warn about overwrite
  // if (sdbClientRegistry.hasOwnProperty(instanceName) &amp;&amp; host) {
  //   console.warn(`A SlashDB client with the name '${instanceName}' already exists, overwriting`);
  // } 

  // handling for the special default instanceName 
  if (instanceName === 'default') {
    // try and get SlashDBProvider config, if it exists
    const { baseUrl, setUpOptions } = useContext(SlashDBContext);

    // when the default hasn't been created yet
    if (!sdbClientRegistry.hasOwnProperty('default')) {
      // if SlashDBProvider configured, create default using its config
      if (baseUrl) {
        if (setUpOptions) {
          sdbClientRegistry['default'] = new SlashDBClient(baseUrl, setUpOptions.username, setUpOptions.apiKey);
        }
        else {
          sdbClientRegistry['default'] = new SlashDBClient(baseUrl);
        }
      }
      // otherwise, create default using provided params
      else {
        sdbClientRegistry['default'] = new SlashDBClient(host, username, apiKey);
      }       
    }      

    else {
      if (host) {
        // if SlashDBProvider component configured and and attempting to overwrite default, don't allow
        if (baseUrl) {
          console.warn(`SlashDB client 'default' was previously configured with SlashDBProvider - cannot overwrite`); 
        }
        else {
          sdbClientRegistry['default'] = new SlashDBClient(host, username, apiKey);
        }
      }
    }
    return sdbClientRegistry['default'];        
  }

  // when host parameter provided, overwrite client object
  else if (host) {
    sdbClientRegistry[instanceName] = new SlashDBClient(host, username, apiKey);
  }
  
  return sdbClientRegistry[instanceName];
};


/**
 * Hook for accessing SlashDB Data Discovery feature
 *
 * @param {string} database name of the database containing the desired resource/table
 * @param {string} resource the resource/table to discover
 * @param {string | DataDiscoveryFilter} [defaultFilter] optional string/DataDiscovery filter object containing a default filter for the resource
 * @param {string} [instanceName] optional name of SlashDB client that has been previously created with useSetUp() hook; default is 'default'
 * @returns {array} array, first element is data for given resource/table and subsequent elements are function references to execute on-demand GET/POST/PUT/DELETE calls on the resource
 */
const useDataDiscovery = (
  database,
  resource,
  defaultFilter = '',
  instanceName = 'default'
) => {
  
  const sdbClient = sdbClientRegistry[instanceName];

  const isMountedRef = useRef(null);

  const [data, setData] = useState([]);
  const [didUpdate, setDidUpdate] = useState(new Date().getTime());

  const handleSetData = (data) => {
    setData(data);
  };

  const handleUpdate = () => {
    setDidUpdate(new Date().getTime());
  };

  const dbResource = new DataDiscoveryResource(database, resource, sdbClient);
 
  
  /**
   * executes GET HTTP requests on resource
   * 
   * @param {string | DataDiscoveryFilter} [filter] optional string/DataDiscovery filter object containing a filter for the resource
   * @param {Object} [headers] object of key/value pairs containing headers for the HTTP request
   */
  const _get = async (filter, headers) => {
    filter = filter ? filter : defaultFilter;
    
    if (headers) {
      dbResource.setExtraHeaders(headers);
    }

    try {
      const r = await dbResource.get(filter);
      handleSetData(r.data);
      dbResource.extraHeaders = {};
    }
    catch(e) {
      dbResource.extraHeaders = {};
      console.error(e);
	  throw Error(e);
    }
  };

  /**
   * executes POST HTTP requests on resource
   * 
   * @param {string | Object} body payload for POST request (usually a JavaScript object)
   * @param {string | DataDiscoveryFilter} [filter] optional string/DataDiscovery filter object containing a filter for the resource
   * @param {Object} [headers] object of key/value pairs containing headers for the HTTP request
   */
  const _post = async (body, filter, headers) => {
    filter = filter ? filter : defaultFilter;

    if (headers) {
      dbResource.setExtraHeaders(headers);
    }

    try {
      await dbResource.post(body, filter)
        .then(handleUpdate);
      dbResource.extraHeaders = {};
    }
    catch(e) {
      dbResource.extraHeaders = {};
      console.error(e);
	  throw Error(e);
    }
  };

  /**
   * executes PUT HTTP requests on resource
   * 
   * @param {string | DataDiscoveryFilter} [filter] optional string/DataDiscovery filter object containing a filter for the resource
   * @param {string | Object} body payload for POST request (usually a JavaScript object) 
   * @param {Object} [headers] object of key/value pairs containing headers for the HTTP request
   */
    const _put = async (filter, body, headers) => {
      filter = filter ? filter : defaultFilter;

      if (headers) {
        dbResource.setExtraHeaders(headers);
      }

      try {
        await dbResource.put(filter, body)
          .then(handleUpdate);
        dbResource.extraHeaders = {};
      }
      catch(e) {
        dbResource.extraHeaders = {};
        console.error(e);
		throw Error(e);
      }
    }

  /**
   * executes DELETE HTTP requests on resource
   * 
   * @param {string | DataDiscoveryFilter} [filter] optional string/DataDiscovery filter object containing a filter for the resource
   * @param {Object} [headers] object of key/value pairs containing headers for the HTTP request
   */
  const _delete = async (filter, headers) => {
    filter = filter ? filter : defaultFilter;

    if (headers) {
      dbResource.setExtraHeaders(headers);
    }

    try {
      await dbResource.delete(filter)
        .then(handleUpdate);
      dbResource.extraHeaders = {};
    }
    catch(e) {
      dbResource.extraHeaders = {};
      console.error(e);
	  throw Error(e);
    }
  };


  useEffect( () => {
    isMountedRef.current = true;
    if (isMountedRef.current) {
      
      async function getData() {
        const r = await dbResource.get(defaultFilter);
        handleSetData(r.data);
      };

      try {
        getData();
      }
      catch(e) {
        console.error(e);
		throw Error(e);
      }
    }
    return () => (isMountedRef.current = false);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [didUpdate]);

  return [data, _get, _post, _put, _delete];
};



/**
 * Hook for accessing SlashDB SQL Pass-Thru feature
 *
 * @param {string} queryName name of the query to execute
 * @param {string | SQLPassThruFilter} [defaultParams] optional string/SQLPassThruFilter filter object containing parameters for the query
 * @param {string} defHttpMethod optional parameter to set the HTTP method used by the query; default is 'get'
 * @param {string} [instanceName] optional name of SlashDB client that has been previously created with useSetUp() hook; default is 'default'
 * @returns {array} array, first element is data for given resource/table and second element is function reference to execute query on demand
 */

const useExecuteQuery = (
  queryName,
  defaultParams,
  defHttpMethod = 'get',
  instanceName = 'default'
) => {
  //redundant call - in case user did not call useSetUp at top level of project
  const sdbClient = sdbClientRegistry[instanceName];
  const sqlQuery = new SQLPassThruQuery(queryName, sdbClient);

  const isMountedRef = useRef(null);

  const [data, setData] = useState([{}]);

  const handleDataSet = (data) => {
    setData(data);
  };

  /**
   * Function to be used for query execution after initial useExecuteQuery has been called
   *
   * @param {String} httpMethod GET, POST, PUT or DELETE - HTTP method to be used.
   * @param {array} parameters Any params user may wish to pass for query.
   * @param {Object} queryStrParameters Query params in key value pairs format to be send via url eg. {limit: 29} => ?limit=29
   * @param {Object} headers Any headers user may wish to pass.
   */
  const _executeQuery = async (
    params,
    body,
    httpMethod = undefined,
    headers = undefined
  ) => {

    params = params ? params : defaultParams;
    httpMethod = httpMethod ? httpMethod : defHttpMethod;

    if (headers) {
      sqlQuery.setExtraHeaders(headers);
    }

    try {
      const method = httpMethod.toLowerCase();
      // post method has body as required arg in position 1, and parameter is optional
      // so flip them around.  also, post method in SQL Pass Thru doesn't accept URL parameters and a body data
      // so set the parameters arg to undefined
      if (method === 'post') {
        [params,body] = [body,params];
        body = undefined;
      }
      const r = await sqlQuery[method](params, body);
      handleDataSet(r.data);
      sqlQuery.extraHeaders = {};
    }
    catch(e) {
      sqlQuery.extraHeaders = {};
      console.error(e);
	  throw Error(e);
    }
  };

  useEffect(() => {
    isMountedRef.current = true;
    if (isMountedRef.current) {
      _executeQuery(defaultParams);
    }
    return () => (isMountedRef.current = false);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [defHttpMethod]);

  return [data, _executeQuery];
};

/** Helper to logout and remove SlashDB clients - used in Auth logout method
 * 
 * @param {string} [instanceName] the SlashDB client instance to log out; if undefined, all clients are logged out
*/
export function removeSdbClients(instanceName = undefined) {
  if (instanceName) {
    if (!sdbClientRegistry.hasOwnProperty(instanceName)) {
      throw Error(`Client '${instanceName}' does not exist`);
    }
    sdbClientRegistry[instanceName].logout();
    delete sdbClientRegistry[instanceName];
  }
  else {
    Object.keys(sdbClientRegistry).forEach( instanceName => {
      sdbClientRegistry[instanceName].logout();
      delete sdbClientRegistry[instanceName];
    });
  }
}

/** Helper to check client authentication status - used in Auth clientIsAuthenticated method
 * @param {string} instanceName the SlashDB client instance check
 * @returns {boolean} flag indicating if client is currently authenticated to SlashDB server
*/
export async function checkClientAuthStatus(instanceName) {
  if (!sdbClientRegistry.hasOwnProperty(instanceName)) {
    console.warn(`Client '${instanceName}' does not exist`);
    return false;
  }
  const status = await sdbClientRegistry[instanceName].isAuthenticated();
  return status;
}


export { useSetUp as default, useDataDiscovery, useExecuteQuery };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Auth.html">Auth</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkClientAuthStatus">checkClientAuthStatus</a></li><li><a href="global.html#removeSdbClients">removeSdbClients</a></li><li><a href="global.html#SlashDBConsumer">SlashDBConsumer</a></li><li><a href="global.html#SlashDBContext">SlashDBContext</a></li><li><a href="global.html#SlashDBProvider">SlashDBProvider</a></li><li><a href="global.html#useDataDiscovery">useDataDiscovery</a></li><li><a href="global.html#useExecuteQuery">useExecuteQuery</a></li><li><a href="global.html#useSetUp">useSetUp</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Tue Oct 25 2022 07:28:25 GMT-0400 (Eastern Daylight Saving Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
